---
- name: Provision DO + Install HA K8s with Kubespray + Addons (no DNS automation)
  hosts: localhost
  connection: local
  gather_facts: false

  vars_files:
    - ./group_vars/all.yml

  vars:
    workspace: "{{ playbook_dir }}"
    kubespray_dir: "{{ workspace }}/kubespray"
    inventory_dir: "{{ kubespray_dir }}/inventory/{{ cluster_name }}"
    kubeconfig_path: "{{ lookup('env','HOME') + '/.kube/config' }}"
    pod_network_cidr: "10.233.64.0/18"
    service_cidr: "10.233.0.0/18"
    k8s_version: "v1.29.6"

  pre_tasks:
    - name: Validate DigitalOcean token present
      ansible.builtin.assert:
        that:
          - do_token | length > 0
        fail_msg: "DO_TOKEN environment variable is required."

    - name: Install base system deps
      ansible.builtin.apt:
        name:
          - git
          - python3-pip
          - python3-venv
          - sshpass
          - rsync
          - jq
        update_cache: true
      become: true

    - name: Install Python packages
      ansible.builtin.pip:
        name:
          - "ansible==9.7.0"
          - "kubernetes==29.0.0"
          - "pyyaml"
          - "jinja2"
        extra_args: --user

    - name: Install Ansible collections
      ansible.builtin.command: >
        {{ lookup('env','HOME') + '/.local/bin/ansible-galaxy' }}
        collection install community.digitalocean kubernetes.core community.general
      register: galaxy_out
      changed_when: galaxy_out.rc == 0

  tasks:
    # -------------------- Create droplets (no backrefs) --------------------
    - name: Create control-plane droplets
      community.digitalocean.digital_ocean_droplet:
        state: present
        oauth_token: "{{ do_token }}"
        name: "{{ '%s-cp-%s' | format(basename, item) }}"
        region: "{{ region }}"
        image: "{{ image }}"
        size: "{{ size_cp }}"
        monitoring: true
        ipv6: false
        backups: false
        ssh_keys: ["{{ ssh_key_id }}"]
        tags: ["{{ cluster_name }}", "role:cp"]
      loop: "{{ range(1, (cp_count | int) + 1) | list }}"

    - name: Create worker droplets (if any)
      community.digitalocean.digital_ocean_droplet:
        state: present
        oauth_token: "{{ do_token }}"
        name: "{{ '%s-wk-%s' | format(basename, item) }}"
        region: "{{ region }}"
        image: "{{ image }}"
        size: "{{ size_worker }}"
        monitoring: true
        ipv6: false
        backups: false
        ssh_keys: ["{{ ssh_key_id }}"]
        tags: ["{{ cluster_name }}", "role:worker"]
      loop: "{{ range(1, (worker_count | int) + 1) | list }}"
      when: worker_count | int > 0

    - name: Wait a bit for droplets to boot
      ansible.builtin.pause:
        seconds: "{{ post_create_wait_seconds | int }}"

    # -------------------- Discover droplets (robust shape handling) --------------------
    - name: Gather droplets info (normalize output shape)
      community.digitalocean.digital_ocean_droplet_info:
        oauth_token: "{{ do_token }}"
      register: do_droplets_all

    - name: Normalize droplets list
      ansible.builtin.set_fact:
        all_droplets: >-
          {{ (do_droplets_all.data.droplets
              if (do_droplets_all.data is mapping and ('droplets' in do_droplets_all.data))
              else do_droplets_all.data) | default([], true) }}

    - name: Filter droplets for this cluster by tag
      ansible.builtin.set_fact:
        cluster_droplets: "{{ all_droplets | selectattr('tags','contains', cluster_name) | list }}"

    - name: Extract masters and workers with names/ids/public IPs
      ansible.builtin.set_fact:
        masters: >-
          {{ {'list': cluster_droplets}
             | json_query("list[?contains(tags, 'role:cp')].{name:name, id:id, ip: networks.v4[?type=='public']|[0].ip_address}") }}
        workers: >-
          {{ {'list': cluster_droplets}
             | json_query("list[?contains(tags, 'role:worker')].{name:name, id:id, ip: networks.v4[?type=='public']|[0].ip_address}") }}

    - name: Print server IP addresses
      ansible.builtin.debug:
        msg:
          - "Masters names: {{ masters | map(attribute='name') | list }}"
          - "Masters IPs:   {{ masters | map(attribute='ip') | list }}"
          - "Workers names: {{ workers | map(attribute='name') | list }}"
          - "Workers IPs:   {{ workers | map(attribute='ip') | list }}"

    # -------------------- API Load Balancer (wait with `until` on a single task) --------------------
    - name: Create DO Load Balancer for kube-apiserver
      community.digitalocean.digital_ocean_load_balancer:
        state: present
        oauth_token: "{{ do_token }}"
        name: "{{ api_lb_name }}"
        region: "{{ region }}"
        droplet_ids: "{{ masters | map(attribute='id') | list }}"
        forwarding_rules:
          - entry_protocol: tcp
            entry_port: 6443
            target_protocol: tcp
            target_port: 6443
        health_check:
          protocol: tcp
          port: 6443
          check_interval_seconds: 10
          response_timeout_seconds: 5
          unhealthy_threshold: 3
          healthy_threshold: 5

    - name: Get LB info until API LB has an address
      community.digitalocean.digital_ocean_load_balancer_info:
        oauth_token: "{{ do_token }}"
      register: do_lbs
      until: >
        (
          (
            (do_lbs.data.load_balancers
              if (do_lbs.data is mapping and ('load_balancers' in do_lbs.data))
              else do_lbs.data) | default([], true)
            | selectattr('name','equalto', api_lb_name) | list | length
          ) > 0
        )
        and
        (
          (
            (
              ( (do_lbs.data.load_balancers
                    if (do_lbs.data is mapping and ('load_balancers' in do_lbs.data))
                    else do_lbs.data) | default([], true)
              | selectattr('name','equalto', api_lb_name) | list | first ) | default({})
            ).ip | default('') | length > 0
          )
          or
          (
            (
              ( (do_lbs.data.load_balancers
                    if (do_lbs.data is mapping and ('load_balancers' in do_lbs.data))
                    else do_lbs.data) | default([], true)
              | selectattr('name','equalto', api_lb_name) | list | first ) | default({})
            ).hostname | default('') | length > 0
          )
        )
      retries: 30
      delay: 10
      changed_when: false

    - name: Extract API LB address
      ansible.builtin.set_fact:
        apiserver_lb_addr: >-
          {{
            (
              (
                (do_lbs.data.load_balancers
                  if (do_lbs.data is mapping and ('load_balancers' in do_lbs.data))
                  else do_lbs.data) | default([], true)
              | selectattr('name','equalto', api_lb_name) | list | first
            ) | default({})
          | community.general.dict_kv('ip','hostname') | select('string') | list | first
          }}
      vars:
        # helper filter: pick 'ip' if present else 'hostname'
        # (dict_kv returns values; select('string') removes empty)
        _ignore: ""

    # -------------------- Kubespray inventory & config --------------------
    - name: Clone Kubespray
      ansible.builtin.git:
        repo: "{{ kubespray_repo }}"
        dest: "{{ kubespray_dir }}"
        version: "{{ kubespray_branch }}"
        depth: 1

    - name: Create inventory directory
      ansible.builtin.file:
        path: "{{ inventory_dir }}"
        state: directory
        mode: "0755"

    - name: Write hosts.yaml
      ansible.builtin.copy:
        dest: "{{ inventory_dir }}/hosts.yaml"
        mode: "0644"
        content: |
          all:
            hosts:
          {% for m in masters %}
              {{ m.name }}:
                ansible_host: {{ m.ip }}
                ip: {{ m.ip }}
                access_ip: {{ m.ip }}
                ansible_user: root
          {% endfor %}
          {% for w in workers %}
              {{ w.name }}:
                ansible_host: {{ w.ip }}
                ip: {{ w.ip }}
                access_ip: {{ w.ip }}
                ansible_user: root
          {% endfor %}
            children:
              kube_control_plane:
                hosts:
          {% for m in masters %}
                  {{ m.name }}: {}
          {% endfor %}
              kube_node:
                hosts:
          {% for m in masters %}
                  {{ m.name }}: {}
          {% endfor %}
          {% for w in workers %}
                  {{ w.name }}: {}
          {% endfor %}
              etcd:
                hosts:
          {% for m in masters %}
                  {{ m.name }}: {}
          {% endfor %}
              k8s_cluster:
                children:
                  kube_control_plane: {}
                  kube_node: {}
              calico_rr: {}

    - name: Configure k8s-cluster.yml (DigitalOcean external CCM + LB address)
      ansible.builtin.copy:
        dest: "{{ inventory_dir }}/group_vars/k8s_cluster/k8s-cluster.yml"
        mode: "0644"
        content: |
          kube_version: "{{ k8s_version }}"
          kube_network_plugin: calico
          kube_pods_subnet: "{{ pod_network_cidr }}"
          kube_service_addresses: "{{ service_cidr }}"
          cloud_provider: external
          external_cloud_provider: digitalocean
          kubelet_loadbalancer_mode: "ipvs"
          loadbalancer_apiserver:
            address: "{{ apiserver_lb_addr }}"
            port: 6443

    - name: Enable dashboard & helm
      ansible.builtin.copy:
        dest: "{{ inventory_dir }}/group_vars/k8s_cluster/addons.yml"
        mode: "0644"
        content: |
          dashboard_enabled: true
          helm_enabled: true

    - name: Disable SSH host key checking locally
      ansible.builtin.lineinfile:
        path: "{{ lookup('env','HOME') + '/.ssh/config' }}"
        line: "Host *\n    StrictHostKeyChecking no\n    UserKnownHostsFile=/dev/null"
        create: true
        mode: "0600"

    - name: Run Kubespray
      ansible.builtin.command: >
        {{ lookup('env','HOME') + '/.local/bin/ansible-playbook' }}
        -i {{ inventory_dir }}/hosts.yaml
        -b -u root cluster.yml
      args:
        chdir: "{{ kubespray_dir }}"

    - name: Fetch kubeconfig from first master
      ansible.builtin.command: >
        scp -o StrictHostKeyChecking=no
        root@{{ (masters | first).ip }}:/etc/kubernetes/admin.conf
        {{ kubeconfig_path }}
      changed_when: true

    - name: Ensure kube dir perms
      ansible.builtin.file:
        path: "{{ kubeconfig_path | dirname }}"
        state: directory
        mode: "0700"

    # -------------------- Addons --------------------
    - name: Download ingress-nginx manifest (cloud provider)
      ansible.builtin.get_url:
        url: https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml
        dest: ./ingress-nginx.yaml

    - name: Apply ingress-nginx
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig_path }}"
        state: present
        src: ./ingress-nginx.yaml

    - name: Download cert-manager manifest
      ansible.builtin.get_url:
        url: https://github.com/cert-manager/cert-manager/releases/download/v1.15.3/cert-manager.yaml
        dest: ./cert-manager.yaml

    - name: Apply cert-manager
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig_path }}"
        state: present
        src: ./cert-manager.yaml

    - name: Create ClusterIssuer (Let's Encrypt)
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig_path }}"
        state: present
        definition:
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: letsencrypt-production
          spec:
            acme:
              email: "{{ email_acme }}"
              server: https://acme-v02.api.letsencrypt.org/directory
              privateKeySecretRef:
                name: le-account-key
              solvers:
                - http01:
                    ingress:
                      class: nginx

    - name: Download ArgoCD install manifest
      ansible.builtin.get_url:
        url: https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
        dest: ./argocd.yaml

    - name: Apply ArgoCD
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig_path }}"
        state: present
        src: ./argocd.yaml

    - name: Expose ArgoCD with Ingress + TLS
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig_path }}"
        state: present
        definition:
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: argocd-server
            namespace: argocd
            annotations:
              kubernetes.io/ingress.class: nginx
              cert-manager.io/cluster-issuer: letsencrypt-production
          spec:
            tls:
              - hosts: ["{{ argocd_domain }}"]
                secretName: argocd-tls
            rules:
              - host: "{{ argocd_domain }}"
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: argocd-server
                          port:
                            number: 80

    - name: Download Kubernetes Dashboard manifest
      ansible.builtin.get_url:
        url: https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml
        dest: ./k8s-dashboard.yaml

    - name: Apply Kubernetes Dashboard
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig_path }}"
        state: present
        src: ./k8s-dashboard.yaml

    - name: Create admin SA & RBAC for Dashboard
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig_path }}"
        state: present
        definition:
          - apiVersion: v1
            kind: ServiceAccount
            metadata:
              name: admin-user
              namespace: kubernetes-dashboard
          - apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRoleBinding
            metadata:
              name: admin-user
            subjects:
              - kind: ServiceAccount
                name: admin-user
                namespace: kubernetes-dashboard
            roleRef:
              kind: ClusterRole
              name: cluster-admin
              apiGroup: rbac.authorization.k8s.io

    - name: Expose Dashboard with Ingress + TLS
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig_path }}"
        state: present
        definition:
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: kubernetes-dashboard
            namespace: kubernetes-dashboard
            annotations:
              kubernetes.io/ingress.class: nginx
              cert-manager.io/cluster-issuer: letsencrypt-production
          spec:
            tls:
              - hosts: ["{{ dashboard_domain }}"]
                secretName: dashboard-tls
            rules:
              - host: "{{ dashboard_domain }}"
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: kubernetes-dashboard
                          port:
                            number: 80

    # -------------------- Wait for Ingress LB & Prompt for DNS --------------------
    - name: Wait for ingress-nginx external IP/hostname to be assigned
      ansible.builtin.command: kubectl -n ingress-nginx get svc ingress-nginx-controller -o json
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: svcjson
      changed_when: false
      retries: 60
      delay: 10
      until: >
        (svcjson.stdout | from_json).status.loadBalancer.ingress is defined and
        ((svcjson.stdout | from_json).status.loadBalancer.ingress | length) > 0 and
        (((svcjson.stdout | from_json).status.loadBalancer.ingress[0].ip | default('')) != '' or
         ((svcjson.stdout | from_json).status.loadBalancer.ingress[0].hostname | default('')) != '')

    - name: Extract ingress external address
      ansible.builtin.set_fact:
        ingress_ip: "{{ (svcjson.stdout | from_json).status.loadBalancer.ingress[0].ip | default('') }}"
        ingress_hostname: "{{ (svcjson.stdout | from_json).status.loadBalancer.ingress[0].hostname | default('') }}"
        ingress_addr: "{{ (ingress_ip | length > 0) | ternary(ingress_ip, ingress_hostname) }}"

    - name: Show DNS instructions
      ansible.builtin.debug:
        msg:
          - "Ingress external address: {{ ingress_addr }}"
          - "Please create A/CNAME records pointing to this address:"
          - "  - {{ argocd_domain }} -> {{ ingress_addr }}"
          - "  - {{ dashboard_domain }} -> {{ ingress_addr }}"

    - name: Confirm DNS added or wait
      ansible.builtin.pause:
        prompt: "Add the DNS records now, then press Enter to continue (or it will wait {{ dns_wait_seconds }}s if dns_wait_mode: seconds)."
        seconds: "{{ 0 if dns_wait_mode == 'prompt' else dns_wait_seconds | int }}"

    # -------------------- Outputs --------------------
    - name: Read ArgoCD initial admin password
      ansible.builtin.command: kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath='{.data.password}'
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: argopass_b64
      changed_when: false

    - name: Print access info
      ansible.builtin.debug:
        msg:
          - "API LB (6443): {{ apiserver_lb_addr }}"
          - "Ingress: {{ ingress_addr }}"
          - "ArgoCD: https://{{ argocd_domain }}  (admin / {{ (argopass_b64.stdout | b64decode) if argopass_b64.stdout else 'N/A' }})"
          - "Dashboard: https://{{ dashboard_domain }} (token printed below)"

    - name: Print Dashboard token
      ansible.builtin.command: kubectl -n kubernetes-dashboard create token admin-user
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: dash_token
      changed_when: false

    - name: Dashboard token (copy this for login)
      ansible.builtin.debug:
        msg: "{{ dash_token.stdout }}"
